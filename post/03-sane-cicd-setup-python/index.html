<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><title class="next-head">Luis Herrada | Full Stack Engineer</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" class="next-head"/><meta http-equiv="X-UA-Compatible" content="ie=edge" class="next-head"/><link href="https://fonts.googleapis.com/css?family=Mada:200,300,400,500,600,700,900&amp;display=swap" rel="stylesheet" class="next-head"/><link href="/static/css/index.css" rel="stylesheet" class="next-head"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-141127632-1" class="next-head"></script><script class="next-head">
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-141127632-1');
      </script><link rel="preload" href="/_next/static/cuBJ4qdFcebHaAIydnZZP/pages/post.js" as="script"/><link rel="preload" href="/_next/static/cuBJ4qdFcebHaAIydnZZP/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-91090225b59433409ab6.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ea39294d8d5dccf83ff1.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-45a5e2a432a79f23ce33.js" as="script"/></head><body><div id="__next"><div class="sidebar"><div class="profile"><img class="pic" src="/static/img/pp.jpg"/><p class="name">Luis Herrada</p><p class="bio">Iâ€™m a Full Stack Engineer with a focus on digital products.</p></div><ul class="links"><li><a class="" href="/about/">About</a></li><li><a class="current" href="/blog/">Blog</a></li><li><a class="" href="/work/">Work</a></li></ul></div><div class="main"><p class="main-title">Blog</p><div class="content"><div class="card"><div class="container container-big limited-width"><h1 class="post-title">A sane CI/CD setup for Python</h1><p class="post-data">June 14, 2019<!-- --> <br/>5 min read</p><div class="post-content"><p>When you&#x27;re working in a real project with a real team, it&#x27;s very important to have a development workflow that allows you to spend time developing actual features instead of constantly fixing broken releases. This is article is a quick guide on how to setup a CI/CD pipeline for your Python project using Gitlab CI.</p><h2>Continuous Integration</h2><p>Continuous Integration is the practice of integrating the work of a team of developers into a shared repository as frequently as possible. The goal is to detect and fix errors fast instead of waiting for things to pile up. When you&#x27;re integrating code frequently (and by frequently I mean daily), you&#x27;re basically de-risking your releases because of a very simple principle: less code to integrate == less things that can go wrong.</p><p>The key practices to do CI successfully are:</p><ul><li>Integrate small and atomic branches into a shared repository</li><li>Before integrating, the entire application should be tested automatically</li><li>Everytime a branch is integrated, it should be built automatically</li><li>When the release is built, it should deploy automatically to a staging server</li></ul><p>In other words: you should iterate fast and automate your process.</p><h2>Continuous Delivery</h2><p>Continuous Delivery on the other hand is the practice of deploying your code to production as frequently as possible, with the goal of reducing the possibilities of something going wrong when releasing new features or bug fixes. Ideally, deployment should be done automatically.</p><p>In other words:</p><ul><li>CI = merge frequently into master</li><li>CD = deploy master frequently to production</li></ul><h2>Automated testing</h2><p>When you&#x27;re adding new code to the repository you <strong>must</strong> add unit or functional tests, this is key for having a sane CI/CD workflow. A lot of beginners think the main benefit of testing is knowing your code works, but the real benefit is that you&#x27;re making sure if someone breaks your code <em>in the future</em> they know about it and fix their code (or your test).</p><p>This is why automated testing is so important, because if you&#x27;re doing frequent integrations you need to make sure you&#x27;re not breaking anything <em>every single time</em>. I won&#x27;t cover unit and functional testing in this article, but if you want to get started with test-driven development you should start reading <a href="https://www.obeythetestinggoat.com/">Obey the testing goat!</a>.</p><h2>Pipeline stages</h2><p>In this guide I use Gitlab CI to execute the pipeline everytime a branch is merged into master, but you&#x27;re free to use a different service like CircleCI, TravisCI or Codeship.</p><p>Think about a CI/CD pipeline as a set of jobs or stages that we execute everytime a new branch is being merged into master. In this guide we are running five stages: three for static code analysis, one for our test suite and one more to deploy our new release.</p><h4>1. Flake8</h4><p>This is a code analyzer to enforce code style rules like the pep8 specification. Running this is very straightforward:</p><pre><code>flake8 --exclude=&#x27;.git,venv,*migrations*,static/lib&#x27;</code></pre><p>If everything is great no output will be returned and the pipeline job will succeed, but if there are errors it will print something like this and return 1 as the exit code.</p><p><img alt="flake8 results" src="/static/img/cicd-python/flake8.png"/></p><h4>2. Radon</h4><p>This is a Python tool to determine the cyclomatic complexity of our code, which means that this stage will throw an alert and fail if our code became too complex.</p><pre><code>radon cc -s -a --ignore=&#x27;venv&#x27; .
radon mi -s --ignore=&#x27;venv&#x27; .</code></pre><p><img alt="cyclomatic complexity" src="/static/img/cicd-python/cc.jpg"/></p><h4>3. Bandit</h4><p>This is a tool originally developed by the OpenStack Security Project, it analyzes our code to find common security issues such as:</p><ul><li>Use of assert</li><li>Hardcoded passwords</li><li>SQL injection</li><li>Binding to all interfaces</li><li>Weak cryptography</li><li>And many others</li></ul><p>You can run bandit like this:</p><pre><code>bandit -r --exclude=&#x27;venv&#x27; .</code></pre><p>You can expect something like this if a vulnerability is found:</p><p><img alt="bandit" src="/static/img/cicd-python/bandit.png"/></p><h4>4. The test suite</h4><p>After all of the static analysis stages pass, it makes sense to run our test suite to see if we broke something.</p><pre><code>python manage.py test -k -v 2</code></pre><p><img alt="pytest" src="/static/img/cicd-python/pytest.png"/></p><h4>5. Deployment</h4><p>This is stage in particular deserves its own blog post because it is an extensive topic, there are a lot of strategies and you should take your time to choose the approach that suits you best.</p><p>First, you have to decide: do you want to PUSH your release from the CI server to your server? or do you want your server to PULL your release whenever it is ready?</p><p>For a push strategy, you can:</p><ul><li>Use <a href="https://docs.gitlab.com/ee/ci/examples/deployment/">dpl</a> for Heroku</li><li>Use <a href="https://www.cyberciti.biz/faq/noninteractive-shell-script-ssh-password-provider/">sshpass</a> to remotely execute commands on your server</li><li>Build a push a Docker image to the Docker Registry and update your containers from whatever you&#x27;re using (Rancher / k8s)</li></ul><p>For a pull strategy, you can:</p><ul><li>Have a cronjob that pulls your changes from Git and executes build.sh when it detects a new release.</li></ul><h2>Gitlab CI</h2><p>Now that you understand the idea behind CI pipelines and their stages, you just need to automate it. We can use Gitlab CI for this and instead of duplicating <a href="https://docs.gitlab.com/ee/ci/">their official documentation</a>, I&#x27;ll just an example of a .gitlab-ci.yml file that you can use for your project. Notice how I:</p><ul><li>Establish what folders to cache between stages so I don&#x27;t have to install the pip requirements everytime</li><li>Specify which image to run my pipeline on. Gitlab CI uses Docker for this.</li><li>Install the chrome driver to run Selenium for my functional tests, but only on my test stage.</li><li>Specify how Gitlab can retrieve the test coverage (reported by coverage.py)</li></ul><p>.gitlab-ci.yml:</p><pre><code>image: python:3.6

services:
  - postgres:9.6
  - redis:3.2

variables:
  PIP_CACHE_DIR: &quot;$CI_PROJECT_DIR/.cache/pip&quot;
  POSTGRES_DB: myproject

cache:
  untracked: true
  key: &quot;test&quot;
  paths:
    - .cache/pip
    - venv/

before_script:
  - python --version
  - pip install virtualenv
  - virtualenv venv
  - source venv/bin/activate
  - pip install -r requirements.txt

stages:
  - pep8
  - radon
  - bandit
  - test

pep8:
  stage: pep8
  artifacts:
    paths:
      - .cache/pip
      - venv
  script:
    - flake8 --exclude=&#x27;.git,venv,*migrations*,static/lib&#x27; .

radon:
  stage: radon
  artifacts:
    paths:
      - .cache/pip
      - venv
  script:
    - radon cc -s -a --ignore=&#x27;venv&#x27; .
    - radon mi -s --ignore=&#x27;venv&#x27; .

bandit:
  stage: bandit
  artifacts:
    paths:
      - .cache/pip
      - venv
  script:
    - bandit -r --exclude=&#x27;venv&#x27; .

test:
  stage: test
  variables:
    DATABASE_URL: &quot;postgresql://postgres:postgres@postgres:5432/$POSTGRES_DB&quot;
    DISPLAY: &quot;:99&quot;
  artifacts:
    paths:
      - .cache/pip
      - venv/
  script:
    - wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -
    - sh -c &#x27;echo &quot;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google-chrome.list&#x27;
    - apt-get -y update
    - apt-get install -y google-chrome-stable
    - apt-get install -yqq unzip
    - wget -O /tmp/chromedriver.zip http://chromedriver.storage.googleapis.com/`curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE`/chromedriver_linux64.zip
    - unzip /tmp/chromedriver.zip chromedriver -d /usr/local/bin/
    - python manage.py migrate auth
    - python manage.py migrate sites
    - python manage.py migrate
    - python manage.py collectstatic --noinput
    - coverage run manage.py test -v 2
    - coverage report
  coverage: &#x27;/TOTAL.+ ([0-9]{1,3}%)/&#x27;</code></pre><h2>Conclusion</h2><p>More than a tool, CI/CD is a set of tools and practices to allow your team be more productive and focus on the fun and creative parts of the job. Adopting CI/CD is the first step into reducing risks on your releases and quickly adapting to business requirements and user needs.</p></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{"content":"When you're working in a real project with a real team, it's very important to have a development workflow that allows you to spend time developing actual features instead of constantly fixing broken releases. This is article is a quick guide on how to setup a CI/CD pipeline for your Python project using Gitlab CI.\n\n## Continuous Integration\nContinuous Integration is the practice of integrating the work of a team of developers into a shared repository as frequently as possible. The goal is to detect and fix errors fast instead of waiting for things to pile up. When you're integrating code frequently (and by frequently I mean daily), you're basically de-risking your releases because of a very simple principle: less code to integrate == less things that can go wrong.\n\nThe key practices to do CI successfully are:\n* Integrate small and atomic branches into a shared repository\n* Before integrating, the entire application should be tested automatically\n* Everytime a branch is integrated, it should be built automatically\n* When the release is built, it should deploy automatically to a staging server\n\nIn other words: you should iterate fast and automate your process.\n\n## Continuous Delivery\nContinuous Delivery on the other hand is the practice of deploying your code to production as frequently as possible, with the goal of reducing the possibilities of something going wrong when releasing new features or bug fixes. Ideally, deployment should be done automatically.\n\nIn other words:\n* CI = merge frequently into master\n* CD = deploy master frequently to production\n\n## Automated testing\nWhen you're adding new code to the repository you **must** add unit or functional tests, this is key for having a sane CI/CD workflow. A lot of beginners think the main benefit of testing is knowing your code works, but the real benefit is that you're making sure if someone breaks your code *in the future* they know about it and fix their code (or your test).\n\nThis is why automated testing is so important, because if you're doing frequent integrations you need to make sure you're not breaking anything *every single time*. I won't cover unit and functional testing in this article, but if you want to get started with test-driven development you should start reading [Obey the testing goat!](https://www.obeythetestinggoat.com/).\n\n## Pipeline stages\nIn this guide I use Gitlab CI to execute the pipeline everytime a branch is merged into master, but you're free to use a different service like CircleCI, TravisCI or Codeship.\n\nThink about a CI/CD pipeline as a set of jobs or stages that we execute everytime a new branch is being merged into master. In this guide we are running five stages: three for static code analysis, one for our test suite and one more to deploy our new release.\n\n#### 1. Flake8\nThis is a code analyzer to enforce code style rules like the pep8 specification. Running this is very straightforward:\n```\nflake8 --exclude='.git,venv,*migrations*,static/lib'\n```\n\nIf everything is great no output will be returned and the pipeline job will succeed, but if there are errors it will print something like this and return 1 as the exit code.\n\n![flake8 results](/static/img/cicd-python/flake8.png)\n\n#### 2. Radon\nThis is a Python tool to determine the cyclomatic complexity of our code, which means that this stage will throw an alert and fail if our code became too complex.\n\n```\nradon cc -s -a --ignore='venv' .\nradon mi -s --ignore='venv' .\n```\n\n![cyclomatic complexity](/static/img/cicd-python/cc.jpg)\n\n\n#### 3. Bandit\nThis is a tool originally developed by the OpenStack Security Project, it analyzes our code to find common security issues such as:\n* Use of assert\n* Hardcoded passwords\n* SQL injection\n* Binding to all interfaces\n* Weak cryptography\n* And many others\n\nYou can run bandit like this:\n\n```\nbandit -r --exclude='venv' .\n```\n\nYou can expect something like this if a vulnerability is found:\n\n![bandit](/static/img/cicd-python/bandit.png)\n\n\n#### 4. The test suite\nAfter all of the static analysis stages pass, it makes sense to run our test suite to see if we broke something.\n\n```\npython manage.py test -k -v 2\n```\n\n![pytest](/static/img/cicd-python/pytest.png)\n\n#### 5. Deployment\nThis is stage in particular deserves its own blog post because it is an extensive topic, there are a lot of strategies and you should take your time to choose the approach that suits you best.\n\nFirst, you have to decide: do you want to PUSH your release from the CI server to your server? or do you want your server to PULL your release whenever it is ready?\n\nFor a push strategy, you can:\n* Use [dpl](https://docs.gitlab.com/ee/ci/examples/deployment/) for Heroku\n* Use [sshpass](https://www.cyberciti.biz/faq/noninteractive-shell-script-ssh-password-provider/) to remotely execute commands on your server\n* Build a push a Docker image to the Docker Registry and update your containers from whatever you're using (Rancher / k8s)\n\nFor a pull strategy, you can:\n* Have a cronjob that pulls your changes from Git and executes build.sh when it detects a new release.\n\n## Gitlab CI\nNow that you understand the idea behind CI pipelines and their stages, you just need to automate it. We can use Gitlab CI for this and instead of duplicating [their official documentation](https://docs.gitlab.com/ee/ci/), I'll just an example of a .gitlab-ci.yml file that you can use for your project. Notice how I:\n* Establish what folders to cache between stages so I don't have to install the pip requirements everytime\n* Specify which image to run my pipeline on. Gitlab CI uses Docker for this.\n* Install the chrome driver to run Selenium for my functional tests, but only on my test stage.\n* Specify how Gitlab can retrieve the test coverage (reported by coverage.py)\n\n.gitlab-ci.yml:\n```\nimage: python:3.6\n\nservices:\n  - postgres:9.6\n  - redis:3.2\n\nvariables:\n  PIP_CACHE_DIR: \"$CI_PROJECT_DIR/.cache/pip\"\n  POSTGRES_DB: myproject\n\ncache:\n  untracked: true\n  key: \"test\"\n  paths:\n    - .cache/pip\n    - venv/\n\nbefore_script:\n  - python --version\n  - pip install virtualenv\n  - virtualenv venv\n  - source venv/bin/activate\n  - pip install -r requirements.txt\n\nstages:\n  - pep8\n  - radon\n  - bandit\n  - test\n\npep8:\n  stage: pep8\n  artifacts:\n    paths:\n      - .cache/pip\n      - venv\n  script:\n    - flake8 --exclude='.git,venv,*migrations*,static/lib' .\n\nradon:\n  stage: radon\n  artifacts:\n    paths:\n      - .cache/pip\n      - venv\n  script:\n    - radon cc -s -a --ignore='venv' .\n    - radon mi -s --ignore='venv' .\n\nbandit:\n  stage: bandit\n  artifacts:\n    paths:\n      - .cache/pip\n      - venv\n  script:\n    - bandit -r --exclude='venv' .\n\ntest:\n  stage: test\n  variables:\n    DATABASE_URL: \"postgresql://postgres:postgres@postgres:5432/$POSTGRES_DB\"\n    DISPLAY: \":99\"\n  artifacts:\n    paths:\n      - .cache/pip\n      - venv/\n  script:\n    - wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -\n    - sh -c 'echo \"deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\" \u003e\u003e /etc/apt/sources.list.d/google-chrome.list'\n    - apt-get -y update\n    - apt-get install -y google-chrome-stable\n    - apt-get install -yqq unzip\n    - wget -O /tmp/chromedriver.zip http://chromedriver.storage.googleapis.com/`curl -sS chromedriver.storage.googleapis.com/LATEST_RELEASE`/chromedriver_linux64.zip\n    - unzip /tmp/chromedriver.zip chromedriver -d /usr/local/bin/\n    - python manage.py migrate auth\n    - python manage.py migrate sites\n    - python manage.py migrate\n    - python manage.py collectstatic --noinput\n    - coverage run manage.py test -v 2\n    - coverage report\n  coverage: '/TOTAL.+ ([0-9]{1,3}%)/'\n\n```\n\n## Conclusion\nMore than a tool, CI/CD is a set of tools and practices to allow your team be more productive and focus on the fun and creative parts of the job. Adopting CI/CD is the first step into reducing risks on your releases and quickly adapting to business requirements and user needs.\n","data":{"id":3,"title":"A sane CI/CD setup for Python","thumbnail":"/static/img/hack-capital.jpg","date":"June 14, 2019","length":"5 min read","category":"devops","description":"This is a quick guide on how to setup a sane CI/CD pipeline for your Python project using Gitlab CI and Docker, so you can spend your time on developing new features instead of stressing about fixing errors, merge conflicts and broken deployments."},"isEmpty":false,"excerpt":""}},"page":"/post","query":{"id":"03-sane-cicd-setup-python"},"buildId":"cuBJ4qdFcebHaAIydnZZP","dynamicBuildId":false,"nextExport":true}</script><script async="" id="__NEXT_PAGE__/post" src="/_next/static/cuBJ4qdFcebHaAIydnZZP/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/cuBJ4qdFcebHaAIydnZZP/pages/_app.js"></script><script src="/_next/static/runtime/webpack-91090225b59433409ab6.js" async=""></script><script src="/_next/static/chunks/commons.ea39294d8d5dccf83ff1.js" async=""></script><script src="/_next/static/runtime/main-45a5e2a432a79f23ce33.js" async=""></script></body></html>